{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;const vec3 uColors[2] = vec3[]( vec3(0.815686, 0.815686, 0.815686), vec3(0.282353, 0.329412, 0.321569) );uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0+0.025*a*(1.0-a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i < 2; i++) { float colorPosition = float(i) / float(2); float nextColorPosition = float(i + 1) / float(2); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(uColors[i]); vec3 linEnd = linear_from_srgb(uColors[i + 1]); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(uColors[2-1]); }out vec4 fragColor;vec3 applyColorToPosition(float position) { vec3 color = vec3(0); position -= (uTime*0.01 + 0.00); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? animatedPos - 1./float(2) : animatedPos - 1./float(2);color = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color += dither; return color; }vec3 linearGrad(vec2 uv) { float position = (uv.x+0.5); return applyColorToPosition(position); }vec3 getGradient(vec2 uv) { return linearGrad(uv); }vec3 getColor(vec2 uv) { switch(2) { case 1: return uColors[0]; break; default: return getGradient(uv); break; } }void main() { vec2 uv = vTextureCoord; vec2 res = uResolution; vec2 pos = vec2(0.49676405483412744, 0.9485763823174639) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.97*2.); uv = rotate(uv, (0.25 - 0.5) * 2. * 3.14159265); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"texture":false,"parentLayer":"61a6914c-082c-48bb-9813-3184ff1cefc6","animating":false,"isMask":1,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.23)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.23;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.23; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.12 == 0.) { vec4 color = texture(uTexture, uv); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.18 - 0.1, 0.18, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.12 * 4.); color.a = bg.a + color.r; } vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.23)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.23;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.23; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.12 == 0.) { vec4 color = texture(uTexture, uv); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.18 - 0.1, 0.18, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.12 * 4.); color.a = bg.a + color.r; } vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","texture":false,"parentLayer":"595e3241-a05d-4b20-970e-41c5f8f4743d","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0; const float kernel[24] = float[]( 0.7978845608028654, 0.795118932516684, 0.7868794322038799, 0.7733362336056986, 0.7547664553859864, 0.7315447328280048, 0.704130653528599, 0.6730536454899063, 0.6388960110447045, 0.6022748643096089, 0.5638237508206051, 0.5241747061566029, 0.48394144903828673, 0.443704309411472, 0.40399737110811773, 0.36529817077804383, 0.3280201493519873, 0.29250790855907144, 0.2590351913317835, 0.2278053882403838, 0.19895427758549736, 0.17255463765302306, 0.1486223271179862, 0.12712341303392466 );out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; float scale = 0.10 / 2.0; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.0); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale) / 2.0, uv.y - modulate.y + (0.08333 * scale) / 2.0 ); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 blurTrail(vec2 uv, vec2 mouseDir) { vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0);for (int i = 0; i <= 24; i++) { float scale = 0.0001 + 0.10 * 0.5; float weight = kernel[i]; vec2 offset = distorted * (1.5 + scale) * mix(1.0, float(i) / ITERATIONS, scale); vec4 samp = texture(uTexture, uv - offset); samp.rgb = chromatic_aberration(samp.rgb, uv - offset, offset * 1.00 * 0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return blurTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;if (1 == 3) { pingpongUv = pixelate(pingpongUv); }vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.16 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision lowp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.47 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;if(0.36 > 0.) { uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.36); }float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.05, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.09)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.56, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI = 3.1415926;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision lowp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition = aVertexPosition;gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = aTextureCoord; vVertexPosition = vertexPosition; }"],"data":{"depth":false}},{"local":{"id":"a3fa0acd-251d-4209-a170-d4c0615580b0","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":["c64c05b9-bd2d-4aac-90c0-1e45c3f45fe6","595e3241-a05d-4b20-970e-41c5f8f4743d"],"size":0.399,"rotation":0,"height":2000,"repeat":0,"fitToCanvas":false,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/13rXAFWRG0dGzck1uJb0dB7Bee52/Photon Fern 03.webp","speed":0.5,"thumb":"https://assets.unicorn.studio/images/13rXAFWRG0dGzck1uJb0dB7Bee52/Photon Fern 03_@thumbnail.webp?authuser=0","translateX":-1,"translateY":10,"width":1461,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"texture":false,"parentLayer":"c600f1ad-353f-49f9-8cba-695ea09307ba","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"pixelate","trackMouse":1,"mouseMomentum":0,"texture":false,"parentLayer":"d48af8e1-060a-41a4-90be-f11cb6b3dca2","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00); float gridSize = (0.08 + 0.01) / 12.; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - pos * vec2(aspectRatio, 1), gridSize); vec2 pixelatedCoord = vec2( uv.x - modulate.x / aspectRatio + (0.08333 * 0.08)/2., uv.y - modulate.y + (0.08333 * 0.08)/2. );vec2 cMod = modulate + 0.5 * gridSize - vec2(gridSize)*0.5; float dist = 1. - length(cMod - vec2(0.5 * gridSize, 0.5 * gridSize)) / length(gridSize); vec4 color = texture(uTexture, pixelatedCoord);if(dist < (1.-0.14)) { if(0 == 1) { color.rgb = vec3(0, 0, 0); } else { discard; } }color *= color.a; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"local":{"id":"de8d7573-060e-48cc-ae6a-626c9a104f70","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1.7777777777777777,"isElement":true,"opacity":0.25,"displace":0,"trackMouse":0.84,"mouseMomentum":0,"blendMode":"ADD","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"shape","borderRadius":0,"coords":[[-29,-48],[193,-48],[193,271],[-29,271]],"effects":["ee0051cd-723f-4da5-ba78-78d03d07a3ee","03343eca-d6bc-4c7a-8319-fea9e83ce251","d48af8e1-060a-41a4-90be-f11cb6b3dca2"],"fill":["#FFFFFF"],"gradientAngle":0,"gradientType":"linear","rotation":0,"translateX":278,"translateY":95,"type":"circle","numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.84); uv = perspectiveUV(uv) - pos; vec4 maskColor = texture(uMaskTexture, vTextureCoord); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (1 > 0) { float originalAlpha = color.a; float blendedAlpha = color.a + background.a * (1.0 - color.a); color.rgb = mix(background.rgb, color.rgb/(originalAlpha + 0.00000001), blendedAlpha); vec3 blendedColor = blend(1, color.rgb, background.rgb); color = mix(background, vec4(blendedColor, originalAlpha), originalAlpha * 0.25); } else { color = mix(background, color/(color.a + 0.00000001), color.a * 0.25); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"vignette","trackMouse":1,"mouseMomentum":0,"texture":false,"parentLayer":"ee0051cd-723f-4da5-ba78-78d03d07a3ee","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return (src + dst) - 1.0; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.35, 1.-0.35); float scaledRadius = 0.31 * 0.5;float adjustedRadius = scaledRadius + 0.41 * scaledRadius; float innerEdge = scaledRadius - 0.41 * scaledRadius * 0.5; float outerEdge = scaledRadius + 0.41 * scaledRadius * 0.5;vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(10 > 0) { vec3 blended = blend(10, vec3(0, 0, 0), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.00), falloff); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"fbm","speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"parentLayer":"03343eca-d6bc-4c7a-8319-fea9e83ce251","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }float hash31(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yzx + 19.19); return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z); } vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yxz+19.19); return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x)); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi; vec3 w = pf * pf * (3.0 - 2.0 * pf); return mix( mix( mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))), w.x), mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))), w.x), w.z), mix( mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))), w.x), mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))), w.x), w.z), w.y); }const int OCTAVES = 6; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.22 * .65); vec2 shift = vec2(100.0); mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5)); for (int i = 0; i < OCTAVES; i++) { value += amp * perlin_noise(st); st.xy *= rot * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.93 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = vec2(0.5, 0.5); float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.64)));vec2 st = (uv * vec2(aspectRatio, 1) + (1. - pos) - vec2(1)) * multiplier * aspectRatio; st = rot(0.18 * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.48*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.48*25. + time)) );float f = fbm(vec3(st + r - drift, 0.48*25. + time)) * 0.35;vec2 offset = (f * 2. + (r * 0.35));vec4 color = texture(uTexture, uv + offset * mDist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"texture":false,"parentLayer":"c64c05b9-bd2d-4aac-90c0-1e45c3f45fe6","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.21)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.21;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.21; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.29 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.21 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.52 - 0.1, 0.52, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.21 * 4.); color.a = bg.a + color.r; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.21)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.21;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.21; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.29 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.21 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.52 - 0.1, 0.52, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.21 * 4.); color.a = bg.a + color.r; } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}}],"options":{"name":"Lumina Florentia","fps":30,"dpi":2,"scale":1,"includeLogo":true,"isProduction":false,"version":"1.2.7"},"version":"1.2.7"}
