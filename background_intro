{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"parentLayer":"61a6914c-082c-48bb-9813-3184ff1cefc6","animating":false,"isMask":1,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.23)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.23;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.23; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.12 == 0.) { vec4 color = texture(uTexture, uv); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.18 - 0.1, 0.18, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.12 * 4.); color.a = bg.a + color.r; } vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.23)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.23;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.23; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.12 == 0.) { vec4 color = texture(uTexture, uv); vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.18 - 0.1, 0.18, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.12 * 4.); color.a = bg.a + color.r; } vec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos); color = color * (maskColor.a * maskColor.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"parentLayer":"c600f1ad-353f-49f9-8cba-695ea09307ba","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"sdf_shape","speed":0.5,"trackMouseMove":0,"mouseMomentum":0,"trackMouse":0.48,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float unionSdf(float a, float b) { return min(a, b); }float sdfBox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); }float sdfPlus(vec3 p, vec3 b) { float ctrl = 1.00 * 0.5 + 0.25; float a = 1. - ctrl; float c = 1. + ctrl; p *= rotY(radians(90.)); p *= rotZ(radians(90.)); float v = sdfBox(p, vec3(b.x * 0.25, b.y * a, b.z * c)); float h = sdfBox(p, vec3(b.x * 0.25, b.y * c, b.z * a)); return unionSdf(v, h); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 xyRepeat(vec3 p, float spacing) { p.xy = vec2( mod(p.x + 0.5 * spacing, spacing) - 0.5 * spacing, mod(p.y + 0.5 * spacing, spacing) - 0.5 * spacing ); return p; }vec3 getRepeat(vec3 p) { float spacing = (1.01 + 0.70 * 0.38) * 8.; return xyRepeat(p, spacing); }vec3 getThreeDRepeat(vec3 p) { float spacing = (1.01 + 0.70 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { vec3 adjustedP = p;vec2 twist = vec2(0, 0);adjustedP /= (0.00 + 0.01);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.70 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.48); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.5).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.5).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.5).z * 2.0 * PI);mat3 animateYMat = rotY(timeY); mat3 animateXMat = rotX(timeX); mat3 animateZMat = rotZ(timeZ);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = animateZMat * animateYMat * animateXMat;adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sdfPlus(p, vec3(1)); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = abs(dot(eyeVector, worldNormal)); float inversefresnelFactor = 1.0 - fresnelFactor; return pow(inversefresnelFactor, power); }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.25 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.12 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);vec2 rayDirOffset = vec2( rand(rd.xy + step) * 2. - 1., rand(rd.xy + step * 2.) * 2. - 1. ) * mix(1., rand(rd.xy + step * 3.), 0.8); refractedRayR.xy += rayDirOffset * (0.1 + disp.r) * 0.02; refractedRayG.xy += rayDirOffset * (0.1 + disp.g) * 0.02; refractedRayB.xy += rayDirOffset * (0.1 + disp.b) * 0.02;refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float size) { float gradientX = getMergedSDF(p + vec3(size, 0.0, 0.0)) - getMergedSDF(p - vec3(size, 0.0, 0.0)); float gradientY = getMergedSDF(p + vec3(0.0, size, 0.0)) - getMergedSDF(p - vec3(0.0, size, 0.0)); float gradientZ = getMergedSDF(p + vec3(0.0, 0.0, size)) - getMergedSDF(p - vec3(0.0, 0.0, size)); vec3 normal = vec3(gradientX, gradientY, gradientZ); return normalize(normal); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0., getMergedSDF(p) - 0.70) * (0.00 + 0.01); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) {float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float antialias_dist = min_dist + min_dist * 0.25;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); if (distance < min_dist) { entryPoint = currentPos; partialAlpha = 1.0; entryNormal = calculateNormal(entryPoint, min_dist); break; } else if(distance < antialias_dist) { partialAlpha = 0.5; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, distance); }if(traveled < 0.05) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 refractionColor = sampleTexture(rd, entryNormal);vec3 lightDir = vec3(((vec2(vec2(0.5, 0.5).x, 1.-vec2(0.5, 0.5).y) - 0.333) * 3.) - vec2(0.5, 0.5), -3.0);float lightAndShadow = dot(entryNormal, lightDir) * 0.25 + 0.25; vec3 lightColor = mix(vec3(1), vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059), 1. - 0.17); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.50 * vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.38 + 0.01); vec3 specularEffect = specFactor * 0.38 * lightColor; vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059) * lightAndShadow, 0.17); finalColor += combinedEffects; vec4 outputColor = mix(bg, vec4(finalColor, 1.0), partialAlpha);return outputColor;}out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 4. / uResolution.y; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","trackMouse":0,"mouseMomentum":0,"parentLayer":"ba0c3af7-0250-4570-932b-bb99cca5a56d","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(0 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 64.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 st) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.50)) * 0.0098; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float bnoz = getBlueNoiseOffset(st) * 0.50;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) { float bno = getBlueNoiseOffset(st + vec2(i/MAX_ITERATIONS)) * 0.50; for (float j = 0.0; j < 4.0; j++) { float x = min(0.999, (i + j) * offset); x += bnoz * 0.01; x = min(0.999, x); vec2 marchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(bno), sin(bno)) * 0.015 * 0.25 * x; color += textureLod(uTexture, marchPos, 0.0).rgb * weight; weight *= decay; } } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0,0,0,1); if(0.50 == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }if(1 != 1) { color = texture(uTexture, uv); float lum = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color = color * smoothstep(0.50 - 0.1, 0.50, lum); } else { float decay = 0.972; vec3 rays = godRays(uv, decay); rays *= vec3(1, 1, 1); color.rgb = Tonemap_tanh(rays); vec4 bg = texture(uBgTexture, uv); color.rgb = bg.rgb + (color.rgb * 0.50 * 4.); color.a = bg.a + color.r; } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"passes":[{"prop":"final","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}}],"options":{"name":"Bio Gladiolus","fps":60,"dpi":2,"scale":1,"includeLogo":false,"isProduction":1,"freePlan":false,"version":"1.2.7"},"version":"1.2.7"}
